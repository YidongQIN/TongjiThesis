% !TeX root = ../Main/thesis.tex
% !TEX program = xelatex
\documentclass[../Main/thesis]{subfiles}
\begin{document}
\chapter{新增内容测试}
\label{cha:new}

之前的两章都是原同济LaTeX模板中的内容。
这一章开始，就是修改、或新加内容的测试。
\cite{RN2018}

当然，不变的是满纸荒唐言，用于填充内容。
\cite{RN2361}

只不过偷了个懒：用\textsf{zhlipsum} 宏包填充废话充篇幅。

\section{下划线测试}
\label{sec:underline}

测试下划线。虽然是不常用的功能，决定是否留在 cls 文件中。

这是默认的\underline{下划线功能}的效果。

\section{多级标题} \label{sec:seclv}

原本的 \textsf{romantitle} 命令没有用。
验证发现，是因为 \textsf{CTeX} 宏包中的字体命令（\textsf{$\backslash$songti}、\textsf{$\backslash$heiti}、\textsf{$\backslash$fangsong}、\textsf{$\backslash$lishu}）等，只对汉字字体生效。
究其原因，因为是 \textsf{xeCJK} 的设计。

于是，重写了控制章节标题的数字编号的命令。
并且可以在 \textbackslash documentclass[titlenum=[rmtitlenum*|sftitlenum|heititlenum]] 中启用。
有衬线* 或 无衬线 或 黑体。

\subsection{二级节标题} \label{ssc:subsec2}

二级节标题形如“1.3.1 xxx”。
格式为：黑体，四号，顶左，单倍行距，段前 12 磅，段后 6 磅，序号与题名间空一个字符。

\subsubsection{三级节标题} \label{sss:subsub3}

三级节标题形如“1.3.1.1 xxx”。
格式为：黑体，小四顶左，单倍行距，段前空 12 磅，段后空 6 磅，序号，且与题名间空一个字符。

\paragraph{四级标题即段落} \label{par:par4}

这是本次新增的层次命令。

四级标题形如：“（1）. xxx”。
格式是仿照正文的，区别就在黑体字体。

\paragraph{另一个四级标题} \label{spr:subpar}

至此，已经有了从0级chapter到4级paragraph共5个级别了，应该够了吧。

\subparagraph{如果必须要有更低的层次}

就像必须要有巫妖王一样。

\subparagraph{但是样式过多也不好}

然而应该不会用到这么多层级吧？
因为有一个问题，那就是 \textsf{paragraph} 和 \textsf{subparagraph} 与各类列表如何区分？
其实挺容易弄混的。

所以如果内容不多，干脆用列表好了，见第~\ref{sec:list}节。

\subsubsection{段落编号}

需要更加完善地测试新命令。
现在测试用 subsubsection 分割。

\paragraph{一个新段落}

多补充几个段落测试。
经过 subsubsection 的分隔，现在应该是全新的段落了。

\paragraph{两个段落} \label{par:second}

正文格式是宋体，小四号（英文用 Times New Roman 体，小四号），两端对齐书写，段落首行左缩进 2 个汉字符。行距 20 磅（段落中有数学表达式时，可根据表达需要设置该段的行距），段前段后 0 磅。

\subsection{最后的段落测试} \label{ssc:lastpar}

如果“跨级”中断呢？
比如这个，用section分隔之后，直接用paragraph会不会重新编号呢。

一下就用伟大的 Git 教程测试一下吧。

\paragraph{基本概念} \label{par:git-concept}

\paragraph{工作区}
working directory = workspace，就是电脑中的目录。

\paragraph{暂存区}
stage = staging area=index
而repository中最重要的就是称为stage（或者叫index）的暂存区
每次修改，如果不用git add到暂存区，那就不会加入到commit中

\paragraph{版本库}
repository = git directory =(local +remote)
可以简单理解成目录下隐藏的.git文件夹。

\paragraph{远程仓库}
remote = remote repository
一个主机，作为团队公用的仓库。一般就是GitHub、bitbucket、gitee等git服务商。
本质上是一个git仓库的地址，形如 git@xxx.com:username/project。
在远程仓库管理中，会给它一个别名，通常是origin表示。

\paragraph{分支}
branch
一个仓库会有多个分支，对用不同的开发进度。
约定俗成的主分支叫master，也就是对外展示用的发布版本。

\subsection{基本流程} \label{ssc:git-workflow}

顺便测试一下多级列表。

\begin{enumerate}[1.]
  \item 调整本地工作目录
  \item 创建项目
  \begin{enumerate}[a.]
    \item 在git网站建立好新项目，把库克隆到本地 \\

    \verb| git clone http:// |

    \item 或者，直接在本地文件夹目录下初始化 \\

    \verb| git init |

    本地初始化后，如要连接网络远程仓库可以再用

    \verb| git remote add |
  \end{enumerate}

  \item 工作区 -> 暂存区：add添加（也叫stage）
    \begin{enumerate}[A.]
      \item 保存修改并添加文件到暂存区（index，或叫staging area)

      \verb| git add <文件名> |

      常用简化命令如下：
        \begin{itemize}[\textbullet]
          \item \verb| git add -A % 所有更改 |
          \item \verb| git add .  % 新增、修改，不含删除 |
          \item \verb| git add -u % 修改、删除，不含新增 |
        \end{itemize}

      \item 或者查看区别

      \verb!git diff!
    \end{enumerate}

  \item 暂存区 -> 版本库：commit提交

  \verb| git commit -a -m "message" |

  其中，-a 表示全部 -m 添加一个留言。
  \begin{enumerate}[(a)]
    \item 如果弹出了vim截面，则用i命令进入编辑模式，输入完成后，esc退回到命令模式，
    \item 然后：wq保存并退出vim，即可回到git命令窗口。
  \end{enumerate}

  \item * 确认提交状况  git status

  \item 推送到远程仓库

  \verb| git push -branch |

  之前步骤1-5都是在本地的版本管理，直到这一步才牵扯。
\end{enumerate}

\section{列表环境测试} \label{sec:list}

列表也是很常用的排版方式。
最方便的方法就是调用 enumerate 宏包定制标签，用 A a R r 1 分别代表大写字母、小写字母、大写罗马、小写罗马和阿拉伯数字编号。

为了偷懒和整齐，这次对一到三级列表的默认样式进行了设计。

\subsection{基本列表} \label{ssc:basiclist}

首先，先熟悉一下基本列表环境。
最常用的是有序列表。

\begin{enumerate}
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{enumerate}

也挺常用的无序列表。

\begin{itemize}
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{itemize}

本次修改的发起者，用description列表展示。
感觉这是一种不怎么常用的列表\footnote{大概是因为 word 中没有吧哈哈哈}。

\begin{description}
  \item[CNchence] 在github.com CNchence
  \item[marquistj13] 在github.com marquistj13
  \item[Wenda] 在github.com Williamwenda
  \item[CNchence] 在github.com CNchence
  \item[Wenda] 在github.com Williamwenda
\end{description}

更常见的是嵌套列表。

\subsection{嵌套}

先填充一些废话。\zhlipsum[6]

可以参见第~\ref{ssc:git-workflow}节的例子，也可以看下面这个。
区别在于，本小节的例子完全展示了\emph{默认参数}情况下的样式。

首先是有序列表。
\begin{enumerate}
  \item 介绍了时间序列分析的相关概念与理论。
  \item 重点对时间序列的平稳性特点、检验方法及平稳模型体系做了详细阐述。
  \begin{enumerate}
    \item 为充分反映出监测序列的季节周期性，建立了一套基于单测点监测序列的季节 ARIMA 模型分析方法。
    \item 对建模过程中的平稳性检验、模型建立步骤、定阶、参数估计以及检验进行了系统的阐述，
  \end{enumerate}
  \item 并对玉峰大桥某监测测点的实测数据进行了季节 ARIMA 建模与预测分析。
  \item 结果表明季节 ARIMA 模型能较好地模拟监测序列的变化趋势，预测精度较高。
  \begin{enumerate}
    \item 用力地嵌套列表。
    \begin{enumerate}
      \item 针对监测序列中某些测点间具有较高的相似性，
      \item 探讨了滞后协整分析的参数估计、模型检验等方法，
    \end{enumerate}
    \item 最后建立了支座位移与温度间的 ADL 与 ECM 模型，
    \item 结果表明该模型具有良好的拟合精度与预测效果。
  \end{enumerate}
\end{enumerate}

然后是无序列表的。
\begin{itemize}
  \item 介绍了时间序列分析的相关概念与理论。
  \item 重点对时间序列的平稳性特点、检验方法及平稳模型体系做了详细阐述。
  \begin{itemize}
    \item 为充分反映出监测序列的季节周期性，建立了一套基于单测点监测序列的季节 ARIMA 模型分析方法。
    \item 对建模过程中的平稳性检验、模型建立步骤、定阶、参数估计以及检验进行了系统的阐述，
  \end{itemize}
  \item 并对玉峰大桥某监测测点的实测数据进行了季节 ARIMA 建模与预测分析。
  \item 结果表明季节 ARIMA 模型能较好地模拟监测序列的变化趋势，预测精度较高。
  \begin{itemize}
    \item 用力地嵌套列表。
    \begin{itemize}
      \item 针对监测序列中某些测点间具有较高的相似性，
      \item 探讨了滞后协整分析的参数估计、模型检验等方法，
    \end{itemize}
    \item 最后建立了支座位移与温度间的 ADL 与 ECM 模型，
    \item 结果表明该模型具有良好的拟合精度与预测效果。
  \end{itemize}
\end{itemize}

下面是一个description列表，不知道中文叫什么。

\begin{description}
  \item [linxdcn] (在github.com linxdcn TongjiThesis)同学汇总的wildwolf、
  \item [svandex] 在github.com svandex masthesis)、
  \begin{description}
    \item [zhao-chen] 在github.com zhao-chen TongjiThesis)的版本。
    \item [收藏有本硕博模板的zhouyuan版] 在github.com zhouyuan/tongjithesis)。
  \end{description}
\end{description}

\section{表格测试} \label{sec:tabletest}

常用的表格是三线表。

\begin{table}[htb]
\centering
\caption{这不是个图}
\label{tab:fig}
\begin{tabular}[c]{lll}
  \toprule[1.5pt]
  0 & 1 & 2 \\ % title row
  \midrule[1pt]
  0 & 1 & 2 \\ % title row
  0 & 1 & 2 \\ % title row
  \bottomrule[1.5pt]
\end{tabular}
\end{table}

先填充一些废话。\zhlipsum[7]

在这里学习一下新定义的列形式。

\begin{table}[htb]
\centering
\caption{tabularx}
\label{tab:tabularx}
\begin{tabularx}{0.7\textwidth}{>{\raggedleft\arraybackslash}X>{\raggedleft\arraybackslash}X>{\centering\arraybackslash}X}
  \toprule[1.5pt]
  0 & 1 & 2 \\ % title row
  \midrule[1pt]
  0 & 1 & 2 \\ % title row
  0 & 1 & 2 \\ % title row
  \bottomrule[1.5pt]
\end{tabularx}
\end{table}

\section{代码环境} \label{sec:code}
常用的代码展示，基于 Listings 宏包。
\begin{lstlisting}[style=monocolor,
  caption={first lst env},
  label={no label},
  name=测试第一个代码,
  language=PythonPlus]
  # import lxml
  import requests
  from bs4 import BeautifulSoup
  import re
\end{lstlisting}

先填充一些废话。\zhlipsum[8]

\begin{lstlisting}[language=ParamML,
  % caption=,
  % label=lst:,
  ]
<O  N="C4000Psi"  T="Material"  D="Concrete">
  <P N="d"  V="0.0000002248"  D="Density"/>
  <P N="E"  V="3604.9965"  D="Modulus of Elasticity"/>
  <P N="Fc28"  V="4"  D="Concrete Compressive Strength"/>
</O>
<!-- comment -->
\end{lstlisting}

由于本模板参考文献部分依赖biblatex-gb7714-2015宏包的2018版本，因此必须在安装好Texlive后更新此宏包，Texlive2018 自带的biblatex-gb7714-2015宏包依然较老，无法正常运行本模板。

\begin{lstlisting}[language=Python,
  caption=Second CODE Block,
  label=lst:2nd,
  style=colored]
  import numpy as np
  def incmatrix(genl1,genl2):
      m = len(genl1)
      #compute the bitwise xor matrix
      M1 = bitxormatrix(genl1)
      for i in range(m-1):
          for j in range(i+1, m):
              [r,c] = np.where(M2 == M1[i,j])
              for k in range(len(r)):
                  VT[(i)*n + r[k]] = 1;

                  if M is None:
                      M = np.copy(VT)
                  else:
                      M = np.concatenate((M, VT), 1)
      return M
\end{lstlisting}

不同于tabled 表~\ref{tab:fig}，源代码的展示用\ref{lst:inp}不会显示开头。
好吧，是我错了。都是需要手动指定其是“图”、“表”、“代码”或“章节”。\textbackslash ref 命令只显示编号。
仔细一想，这样也好，只做最小程度的工作，格式完全可以 \textbackslash newcommand 或者用 VSCode 脚本辅助。

第~\ref{sec:code} 小节的内容也被引用了。

\begin{lstlisting}[language=Python,
  caption=中文标题没有括号,
  label=lst:outer,
  style=colorEX]
  import numpy as np
  def incmatrix(genl1,genl2):
      m = len(genl1)
      #compute the bitwise xor matrix
      M1 = bitxormatrix(genl1)
      for i in range(m-1):
          for j in range(i+1, m):
              [r,c] = np.where(M2 == M1[i,j])
              for k in range(len(r)):
                  VT[(i)*n + r[k]] = 1;
      return M
\end{lstlisting}

推荐使用其包管理器更新此宏包，如若更新失败（我更新了好几次都失败了，它还把我的这个宏包给删了，郁闷），那么可按照官方页面在github.com/hushidong/biblatex-gb7714-2015的安装介绍，在你的tex安装目录搜索biblatex-gb7714-2015文件夹，将该文件夹中的四个文件替换为官方页面在github.com/hushidong/biblatex-gb7714-2015提供的文件即可。

这里测试三个代码片段的引用。

代码片段，没有前缀，直接中括号，见 \ref{no label} 代码。

代码片段，是按照现有的snippet直接插入的样式 \ref{lst:2nd} 代码。

代码片段， \ref{lst:outer} 代码，手动在环境之后加了label，可以被 vscode 插件检测到。

代码片段， \ref{lst:parenthesis} 代码，仅供测试，caption 加了花括号。

貌似不能从ref命令中自动调用。难道需要手动加 label 更好吗？
\begin{lstlisting}[language=Python,
  caption={Must have Parenthesis},
  label=lst:parenthesis]
  import numpy as np
  def incmatrix(genl1,genl2):
      m = len(genl1)
      #compute the bitwise xor matrix
      M1 = bitxormatrix(genl1)
      for i in range(m-1):
          for j in range(i+1, m):
              [r,c] = np.where(M2 == M1[i,j])
              for k in range(len(r)):
                  VT[(i)*n + r[k]] = 1;
      return M
\end{lstlisting}

还可以直接导入。
\lstinputlisting[language=Python,
  caption=inputted Python,
  label=lst:inp,
  style=monocolor,
  ]{../code/tmp.py}


\section{行内原样抄写并带有双引号命令}
\label{sec:newfunction}

考虑到会出现一些后缀名或者文件名之类的内容，所以新添了一个命令：
\verb|\tvt|，
其作用是在一个原样抄写的文字外围加上双引号。

CIS/2标准使用\tvt{*.stp}中性格式文件保存数据模型的数据。
对应上述梁的大纲，该梁在\texttt{*.stp}中性格式文件中的主要内容如下.


\end{document}
