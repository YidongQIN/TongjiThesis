% !TeX root = ../Main/thesis.tex
% !TEX program = xelatex
\documentclass[../Main/thesis]{subfiles}
\begin{document}
\chapter{新增内容测试}
\label{cha:new}

\section{说明}
\label{sec:new-intro}

之前的两章都是原同济LaTeX模板中的内容。
这一章开始，就是修改、或新加内容的测试\cite{mohrssBIM}。
完整的修改思路和参考资料都在 \texttt{README.md} 文件中，这一章仅仅是是用于测试的部分修改的实际效果，比如多级列表等。

只不过偷了个懒：用 \verb|zhlipsum| 宏包填充废话充篇幅 \cite{HowDigital}。
否则，如果段内字数太少，有时候不利于演示效果。

\section{多级标题} \label{sec:seclv}

先填充一些废话。\zhlipsum[4]

\subsection{二级节标题} \label{ssc:subsec2}

二级节标题形如\tvt{1.3.1 xxx}。

格式为：黑体，四号，顶左，单倍行距，段前 12 磅，段后 6 磅，序号与题名间空一个字符。

\subsubsection{三级节标题} \label{sss:subsub3}

三级节标题形如\tvt{1.3.1.1 xxx}。

格式为：黑体，小四，顶左，单倍行距，段前空 12 磅，段后空 6 磅，序号，且与题名间空一个字符。

\paragraph{四级标题即段落} \label{par:par4}

段落 paragraph 是本次新增的层次命令。

四级标题形如\tvt{（1）xxx}。

格式为：黑体，小四号，顶左，单倍行距，段前 6 磅，段后 0 磅，序号与题名间没有空。

格式是仿照正文的，区别就在黑体字体。

\paragraph{另一个四级标题} \label{spr:subpar}

其实，段落的样式已经与序号列表有一些相似了，相差可能也就是“黑体”以及“顶格书写”了吧。

至此，已经有了从0级chapter到4级paragraph共5个级别了，应该够了吧。

\subparagraph{如果必须要有更低的层次。}
如果必须要有最低等级的标题，就像必须要有巫妖王一样。

\sout{其实就是为了满足强迫症。}
故还是把最低层级的 subparagraph 样式给定义了。

\subparagraph{五级标题即子段落。}
五级标题形如 \tvt{\textcircled*{1}xxx}。

最初设定格式为：楷书，小四号，左侧空两格，单倍行距，段前 6 磅，段后 0 磅，序号与题名间没有空。
其中，用命令 \verb|\chinese{}| 产生汉字数字，并用命令 \verb|\setcounter{secnumdepth}{5}| 把目录编号深度更改为 subparagraph 对应的等级 5。

\subparagraph{但是样式过多也不好。}
应该不会用到这么多层级吧？
一个比较明显的问题就是 \verb|paragraph| 和 \verb|subparagraph| 的样式，难以与各类列表高效区分。
\footnote{所以如果内容不多，推荐采用列表，见第~\ref{sec:list}节的展示。}

所以选择了一个方案，其实就是避免与正文（列表）采用同样的字体。
四级标题的黑体是继承自校方模板的前几级标题设置，而五级标题的楷体参考了国家公文写作的有关规范 \cite{GBT9704}。

\subparagraph{更新子段落样式。}
这是考虑到两方面原因：
\begin{inlinecn}
  \item 论文中完全没有说过“楷体”字体，擅自加入有些多余；
  \item 中文数字比如一、二、三等，并不适合作为低等级标题的数字编号，这不符合日常使用习惯。
\end{inlinecn}
所以，最终还是撤销了这些调整。

调整子段落的格式为这样：
\begin{inline}
  \item 子段落标题的字体格式与正文格式完全一样，只是会自动编号；
  \item 子段落标题与其他标题的差别在于，不会换行。
  \item 段落标题的字体与 section 相似，仍旧保持黑体、独立成段；
  \item 但是，段落标题的编号不像各级 section 那样包含上级编号。
\end{inline}

\subsubsection{段落编号}

需要更加完善地测试新命令。
现在测试用 subsubsection 分割后，能否正常编号。

\paragraph{一个新段落}

多补充几个段落测试。
经过 subsubsection 的分隔，现在应该是全新的段落了。

\paragraph{两个段落} \label{par:second}

正文格式是宋体，小四号（英文用 Times New Roman 体，小四号），两端对齐书写，段落首行左缩进 2 个汉字符。
行距 20 磅（段落中有数学表达式时，可根据表达需要设置该段的行距），段前段后 0 磅。

\subsection{最后的段落测试} \label{ssc:lastpar}

如果“跨级”中断呢？
比如这个，用section分隔之后，直接用paragraph会不会重新编号呢。

一下就用伟大的 Git 教程测试一下吧。

\paragraph{基本概念} \label{par:git-concept}

\paragraph{工作区}
working directory = workspace，就是电脑中的目录。

\paragraph{暂存区}
stage = staging area=index
而repository中最重要的就是称为stage（或者叫index）的暂存区
每次修改，如果不用git add到暂存区，那就不会加入到commit中

\paragraph{版本库}
repository = git directory =(local +remote)
可以简单理解成目录下隐藏的.git文件夹。

\paragraph{远程仓库}
remote = remote repository
一个主机，作为团队公用的仓库。一般就是GitHub、bitbucket、gitee 等git服务商。
本质上是一个git仓库的地址，形如 git@xxx.com:username/project。
在远程仓库管理中，会给它一个别名，通常是origin表示。

\paragraph{分支}
branch
一个仓库会有多个分支，对用不同的开发进度。
约定俗成的主分支叫master，也就是对外展示用的发布版本。

\subsection{总结章节样式}
\label{ssc:summary-title-formats}

实际上，章节样式划分为两类：
\begin{enumerate}[(1)]
  \item 章与各级节都是传统、常用的多层次数字编号，对应 \LaTeX 层次 0 $\sim$ 3。
  \begin{itemize}[\textbullet]
    \item 区别在于，本次新增了 subsubsetion 级别，即 “x.x.x.x” 的编号形式。
  \end{itemize}
  \item 段落是新增的，其编号由全角括号包围，对应 \LaTeX 层次 4 $\sim$ 5。
  \begin{itemize}[\textbullet]
    \item paragraph 的样式与章、节级相似，均为黑体、无缩进。
    \item subparagraph 的样式与正文相同，包括宋体、小四、缩进 2 字符。
  \end{itemize}
\end{enumerate}

\section{列表环境测试} \label{sec:list}

列表也是很常用的排版方式。
最方便的方法就是调用 enumerate 宏包定制标签，用 A a R r 1 分别代表大写字母、小写字母、大写罗马、小写罗马和阿拉伯数字编号。

为了偷懒和整齐，这次对一到三级列表的默认样式进行了设计。

\subsection{基本列表} \label{ssc:basiclist}

首先，先熟悉一下基本列表环境。
最常用的是有序列表。

\begin{enumerate}
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{enumerate}

也挺常用的无序列表。

\begin{itemize}
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{itemize}

本次修改的发起者，用description列表展示。
感觉这是一种不怎么常用的列表\footnote{大概是因为 word 中没有吧哈哈哈}。

\begin{description}
  \item[CNchence] 在github.com CNchence
  \item[marquistj13] 在github.com marquistj13
  \item[Wenda] 在github.com Williamwenda
  \item[CNchence] 在github.com CNchence
  \item[Wenda] 在github.com Williamwenda
\end{description}

更常见的是嵌套列表。

\subsection{嵌套}

先填充一些废话。\zhlipsum[6]

本小节的例子完全展示了 \emph{默认参数} 情况下的样式。

首先是有序列表。
\begin{enumerate}
  \item 介绍了时间序列分析的相关概念与理论。
  \item 重点对时间序列的平稳性特点
  \item 检验方法及平稳模型体系做了详细阐述。
  \begin{enumerate}
    \item 为充分反映出监测序列的季节周期性，建立了一套基于单测点监测序列的
    \item 对建模过程中的平稳性检验、模型建立步骤、定阶、参数估计以及检验进行了系统的阐述，
  \end{enumerate}
  \item 并对大桥某监测测点的实测数据进行了
  \item 结果表明
  \begin{enumerate}
    \item 用力地嵌套列表。
    \begin{enumerate}
      \item 针对监测序列中某些测点间具有较高的相似性，
      \item 探讨了滞后协整分析的参数估计
    \end{enumerate}
    \item 最后建立了支座位移与温度间的
    \item 结果表明该模型具有良好的拟合精度与预测效果。
  \end{enumerate}
\end{enumerate}

然后是无序列表的。
\begin{itemize}
  \item 介绍了时间序列分析的相关概念与理论。
  \item 重点对时间序列的平稳性特点
  \item 检验方法及平稳模型体系做了详细阐述。
  \begin{itemize}
    \item 为充分反映出监测序列的季节周期性，建立了一套基于单测点监测序列的
    \item 对建模过程中的平稳性检验、模型建立步骤、定阶、参数估计以及检验进行了系统的阐述，
  \end{itemize}
  \item 并对大桥某监测测点的实测数据进行了
  \item 结果表明
  \begin{itemize}
    \item 用力地嵌套列表。
    \begin{itemize}
      \item 针对监测序列中某些测点间具有较高的相似性，
      \item 探讨了滞后协整分析的参数估计
    \end{itemize}
    \item 最后建立了支座位移与温度间的
    \item 结果表明该模型具有良好的拟合精度与预测效果。
  \end{itemize}
\end{itemize}

下面是一个description列表，不知道中文叫什么。

\begin{description}
  \item [linxdcn] 在github.com linxdcn 同学汇总的、
  \item [svandex] 在 github.com svandex masthesis、
  \begin{description}
    \item [zhao-chen] 在 github.com zhao-chen TongjiThesis 的版本。
    \item [收藏有本硕博模板的zhouyuan版] 在 github.com zhouyuan tongjithesis。
  \end{description}
\end{description}

\zhlipsum[33]

顺便测试一下一个复杂的多级列表。
其实就是在嵌套的基础上， 手动定制多级列表的 label 形式。

\begin{enumerate}[1.]
  \item 调整本地工作目录
  \item 创建项目
  \begin{enumerate}[a.]
    \item 在git网站建立好新项目，把库克隆到本地 \\

    \verb| git clone http:// |

    \item 或者，直接在本地文件夹目录下初始化 \\

    \verb| git init |

    本地初始化后，如要连接网络远程仓库可以再用

    \verb| git remote add |
  \end{enumerate}

  \item 工作区 -> 暂存区：add添加（也叫stage）
    \begin{enumerate}[A.]
      \item 保存修改并添加文件到暂存区（index，或叫 staging area）

      \verb| git add <文件名> |

      常用简化命令如下：
        \begin{itemize}[\textbullet]
          \item \verb| git add -A | 所有更改
          \item \verb| git add .  | 新增、修改，不含删除
          \item \verb| git add -u | 修改、删除，不含新增
        \end{itemize}

      \item 或者查看区别

      \verb! git diff !
    \end{enumerate}

  \item 暂存区 -> 版本库：commit提交

  \verb| git commit -a -m "message" |

  其中，-a 表示全部 -m 添加一个留言。
  \begin{enumerate}[(a)]
    \item 如果弹出了vim截面，则用i命令进入编辑模式，
    \item 输入完成后，esc退回到命令模式，
    \item 然后：wq保存并退出vim，即可回到git命令窗口。
  \end{enumerate}

  \item * 确认提交状况  git status

  \item 推送到远程仓库

  \verb| git push -branch |

  之前步骤1-5都是在本地的版本管理，直到这一步才牵扯。
\end{enumerate}

下面是行内列表的展示。

\begin{inline}[1)]
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{inline}

\section{表格测试} \label{sec:tabletest}

常用的表格是三线表。

\begin{table}[htb]
\centering
\caption{这不是个图}
\label{tab:fig}
\begin{tabular}[c]{lll}
  \toprule[1.5pt]
  0 & 1 & 2 \\ % title row
  \midrule[1pt]
  0 & 1 & 2 \\
  0 & 1 & 2 \\
  \bottomrule[1.5pt]
\end{tabular}
\end{table}

先填充一些废话。\zhlipsum[7]

在这里学习一下新定义的表格形式。
利用宏包 tabularx 产生的表格，需要一个参数指定总宽度，列定义时用 \tvt{X} 表示平均分配列宽的列。

\begin{table}[htb]
\centering
\caption{tabularx}
\label{tab:tabularx}
\begin{tabularx}{0.7\textwidth}{>{\raggedleft\arraybackslash}X|>{\raggedright\arraybackslash}X|>{\centering\arraybackslash}X}
  \toprule[1.5pt]
  raggedleft X & raggedright X & centering X \\ % title row
  \midrule[1pt]
  0 & 1 & 2 \\
  0 & 1 & 2 \\
  \bottomrule[1.5pt]
\end{tabularx}
\end{table}

当然，可以用 \tvt{>{}} 和 \tvt{<{}} 命令更改对齐方式、或者列宽分配比例。
在宏包文件中把它们定义成了单独的列样式。
分别用 a、s 和 d 表示左对齐、居中对齐和右对齐。
此外，还必须参数 \tvt{{n}} 参数设置列宽分配比例。

\begin{table}[htbp]
  \centering
  \caption{Fixed width table}
  \begin{tabularx}{\linewidth}{X|a{0.6}|s{1.5}|d{0.9}}
    \toprule[1.5pt]
    X & a\{0.6\} & s\{1.5\} & d\{0.9\} \\ % title row
    \hline
    1 & 2 & 3 & 4 \\
    2 & 3 & 3 & 4 \\
    \bottomrule[1.5pt]
  \end{tabularx}
  \end{table}

上述两个 tabularx 的例子中，划出了竖向分割线，是为了更直观地展示列宽分布。
同时也展示了 \tvt{\textbackslash midrule[xpt]} 会截断竖向分割线，而 \verb|\hline| 不会。
这里也对比一下用 \verb|\verb\| 命令或者 \texttt{\textbackslash texttt\{\}\textbackslash} 输入反斜线的差别。

\section{代码环境}
\label{sec:code}

常用的代码展示，基于 Listings 宏包。

\subsection{Listings 环境展示}
\label{ssc:listings}

\begin{lstlisting}[style=monocolor,
  caption={first lst env},
  label={no label},
  name=测试第一个代码,
  language=PythonPlus]
  # import lxml
  import requests
  from bs4 import BeautifulSoup
  import re
\end{lstlisting}

先填充一些废话。\zhlipsum[8]

\begin{lstlisting}[
  language=ParamML,
  style=Firefox_XML,
  title= ParamML 在 Firefox 中的渲染,
  ]
<O  N="C4000Psi"  T="Material"  D="Concrete">
  <P N="d"  V="0.0000002248"  D="Density"/>
  <P N="E"  V="3604.9965"  D="Modulus of Elasticity"/>
  <P N="Fc28"  V="4"  D="Concrete Compressive Strength"/>
</O>
<!-- comment -->
\end{lstlisting}

\begin{lstlisting}[
  language=OBrIM_ParamML,
  % language=ParamML,
  % style=OpenBrIM,
  title= ParamML 在 OpenBrIM APP 中的渲染,
  ]
<O  N="C4000Psi"  T="Material"  D="Concrete">
  <P N="d"  V="0.0000002248"  D="Density"/>
  <P N="E"  V="3604.9965"  D="Modulus of Elasticity"/>
  <P N="Fc28"  V="4"  D="Concrete Compressive Strength"/>
</O>
<!-- comment -->
\end{lstlisting}

不同于tabled 表~\ref{tab:fig}，源代码的展示用\ref{lst:inp}不会显示开头。
好吧，是我错了。都是需要手动指定其是“图”、“表”、“代码”或“章节”。\textbackslash ref 命令只显示编号。
仔细一想，这样也好，只做最小程度的工作，格式完全可以 \textbackslash newcommand 或者用 VSCode 脚本辅助。

测试把 ParamML 的分离语言定义和样式定义。
有一些几个小技巧需要注意。
结尾处的 \texttt{>} 不能与前面的字符串有空格，否则会解析错误，导致全部以 keyword 形式高亮。
如果属性之间间距不够空格不够，可以尝试在代码中用四个空格间隔。
浮动体内的代码左侧最好不要缩进，以免高亮错误。

\begin{lstlisting}[
  language=ParamML,
  style=OpenBrIM,
  % caption=,
  % label=lst:,
  ]
<O  N="FEA Surface"  T="Project">
  <O  N="N1"  T="Node"/>
  <O  N="N2"  T="Node"  X="5" Y="0"/>
  <O  N="N3"  T="Node"  X="5" Y="5"/>
  <O  N="N4"  T="Node"  X="0" Y="5"/>
  <O  N="N5"  T="Node"  Z="5"/>
  <O  N="N6"  T="Node"  Rx="5"  Ry="0"  Rz="5"/>
  <O  N="N7"  T="Node"  Tx="5"  Ty="5"  Tz="5"/>
  <O  N="N8"  T="Node"  C="0"  R="5"/>
  <O  T="FELine"  Node1="N1"  Node2="N5"/>
  <O  T="FELine"  Node3="N2"  Node4="N6"/>
  <O  T="FELine"  Factor="N3"  Case="N7"/>
  <O  T="FELine"  Extends="N4"  Role="N8"/>
  <O  N="S1"  T="FESurface">
    <P  N="Node1"  V="N5"  T="Node"/>
    <P  N="Node2"  V="N6"  T="Node"/>
    <P  N="Node3"  V="N7"  T="Node"/>
    <P  N="Node4"  V="N8"  T="Node"/>
    <P  N="Thickness"  V="0.5"/>
  </O>
  <O  N="LLE"  P1="0"  P2="0"  P3="0">
    <P  Lng="0"  Lat="1"  Elev="2"/>
  </O>
</O>
\end{lstlisting}

测试 Python 的语法高亮。

\begin{lstlisting}[language=Python,
  caption=Second CODE Block,
  label=lst:2nd,
  style=colored]
  import numpy as np
  def incmatrix(genl1,genl2):
      m = len(genl1)
      #compute the bitwise xor matrix
      M1 = bitxormatrix(genl1)
      for i in range(m-1):
          for j in range(i+1, m):
              [r,c] = np.where(M2 == M1[i,j])
              for k in range(len(r)):
                  VT[(i)*n + r[k]] = 1;

                  if M is None:
                      M = np.copy(VT)
                  else:
                      M = np.concatenate((M, VT), 1)
      return M
\end{lstlisting}

为 宏包 Listings 定义了许多种语言和样式，比如XML，再基于XML定义了 ParamML。
语法比较简单，看看 \tvt{tongjithesis.sty} 文件 也就懂了。
故不赘述。

第~\ref{sec:code} 小节的内容也被引用了。

\begin{lstlisting}[language=Python,
  caption=中文标题没有括号,
  label=lst:outer,
  style=colorEX]
  import numpy as np
  def incmatrix(genl1,genl2):
      m = len(genl1)
      #compute the bitwise xor matrix
      M1 = bitxormatrix(genl1)
      for i in range(m-1):
          for j in range(i+1, m):
              [r,c] = np.where(M2 == M1[i,j])
              for k in range(len(r)):
                  VT[(i)*n + r[k]] = 1;
      return M
\end{lstlisting}

还可以直接导入一个外部文件，并摘选其中的部分行。

\lstinputlisting[language=Python,
  caption=inputted Python,
  label=lst:inp,
  style=monocolor,
  ]{../code/tmp.py}

先填充一些废话。\zhlipsum[12]

\begin{lstlisting}[language=EXPRESS,
  caption=IfcLine的EXPRESS定义,
  label=lst:ifcline-express,
  style=colorEX]
ENTITY IfcLine
  SUBTYPE OF (IfcCurve)
  Pnt : IfcCartesianPoint;
  Dir : IfcVector;
  WHERE SameDim : Dir.Dim = Pnt.Dim;
END_ENTITY;
;; escape ;; // Escaped
;* escape $a_i \neq b_j$ *; // Escaped
%* escape $a_i \neq b_j$ *% // Escaped
\end{lstlisting}

\begin{lstlisting}[language=EXPRESS,
  caption=CIS/2中的梁,
  label=lst:cis2beam,
  style=colorEX]
#1 = DIMENSIONAL_EXPONENTS (1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0);
#2 = (CONTEXT_DEPENDENT_UNIT ('INCH') LENGTH_UNIT ().. NAMED_UNIT ( #1 ));
--......;
;*escape $a_i \neq b_j$ *; // Escaped
#959 = SECTION_PROFILE (2 , 'W14X53' , $ , $ , 5 , .F.);
--......;
#3096 = COORD_SYSTEM_CARTESIAN_3D ('Design Part' , 'Design Part Coordinate System' , $ , 3 , #3097 );
#3097 = AXIS2_PLACEMENT_3D ('Axid3d' , #3098 , #3099 , #3100 );
#3098 = CARTESIAN_POINT ('Origin' , ( -40.237139504348 , -505.625249238341 , 168. );
#3099 = DIRECTION ('Orientation' , (0. , 1. , 0.));
#3100 = DIRECTION ('Direction' , (0. , 0. , -1.));
--......;
#3102 = ASSEMBLY_DESIGN_STRUCTURAL_MEMBER_LINEAR (5 , '5' , $ , $ , 0 , .LOW. , .F. , F. , () , () , $ , .UNDEFINED_ROLE , UNDEFINED_CLASS. , .UNDEFINED.);
#3103 = DESIGN_PART ('' , #3104 , ( #3102 ) , ( #3096 ));
#3104 = PART_PRISMATIC_SIMPLE (5 , 'PP5' , $ , $ , .UNDEFINED. , $ , #959 , #3105 , $ , $);
#3105 = POSITIVE_LENGTH_MEASURE_WITH_UNIT (POSITIVE_LENGTH_MEASURE (168.) , #2 );
\end{lstlisting}

\subsubsection{代码片段 Listings 引用}

这里测试三个代码片段的引用。

代码片段，没有前缀，直接中括号，见 \ref{no label} 代码。

代码片段，是按照现有的snippet直接插入的样式 \ref{lst:2nd} 代码。

代码片段， \ref{lst:outer} 代码，手动在环境之后加了label，可以被 vscode 插件检测到。

代码片段， \ref{lst:parenthesis} 代码，仅供测试，caption 加了花括号。

貌似不能从ref命令中自动调用。难道需要手动加 label 更好吗？
\begin{lstlisting}[language=Python,
  caption={Must have Parenthesis},
  label=lst:parenthesis]
import numpy as np
def incmatrix(genl1,genl2):
    m = len(genl1)
    #compute the bitwise xor matrix
    M1 = bitxormatrix(genl1)
    for i in range(m-1):
        for j in range(i+1, m):
            [r,c] = np.where(M2 == M1[i,j])
            for k in range(len(r)):
                VT[(i)*n + r[k]] = 1;
    return M
\end{lstlisting}
\subsection{算法}
\label{ssc:algo}

比代码更加抽象的方式就是算法展示了。

先填充一些废话。\zhlipsum[7]

目前，推荐采用 algorithm2e 宏包，因为它更新，设置更加方便。
原本的 algorithms 宏包已被注释掉了。

\begin{algorithm}[htbp]
  \SetAlgoLined
  \KwData{this text}
  \KwResult{how to write algorithm with \LaTeX2e }
  \KwIn{A list $[a_i]$, $i=1, 2, \cdots, n$, where each element is an
integer.}
  \KwOut{Processed list.}
  initialization\;
  \While{not at end of this document}{
  read current\;
  \eIf{understand}{
  go to next section\;
  current section becomes this one\;
  }{
  go back to the beginning of current section\;
  }
  }
  \caption{How to write algorithms}
\end{algorithm}

传统的方法采用的是 algorithms 宏包，它其实是两个宏包 algorithm 与 algorithmic 的合集。
其中，algorithm 是个 float 环境，相当于 table。
algorithmic 负责生成内容，相当于 tabular。

总体来说，algorithms 比较简单，功能较少。比如，如果要调整其宽度，需要用 minipage 手动计算，而且会取消 \textbackslash intextsep 导致上下间距过小。

\section{特殊标记方式}
\label{sec:mark-methods}

先填充一些废话。\zhlipsum[9]

\subsection{下划线测试}
\label{ssc:underline}

这是默认的 \underline{下划线功能测试，不能换行。可以看到，比 MS Word 的下划线好看多了。} 的效果。

这是宏包的 \uline{下划线功能测试，可以看到，比 MS Word 的下划线好看多了。不会产生文字底线与下划线重合的问题，而且可以自动换行。但是会有断线问题，就是两个字符之间有中断问题} 的效果。

汉字宏包的 \CJKunderline{下划线功能测试，遭遇标点符号会自动断开。可以长换行也能实现。可以看到，比 MS Word 的下划线好看多了，不会产生文字底线与下划线重合的问题。} 的效果。

\subsection{行内原样抄写并带有双引号命令}
\label{ssc:tvt}

考虑到会出现一些后缀名或者文件名之类的内容，所以新添了一个命令：
\verb|\tvt{}|，
其作用是在一个原样抄写的文字外围加上双引号。

CIS/2标准使用\tvt{*.stp}中性格式文件保存数据模型的数据。
对应上述梁的大纲，该梁在\texttt{*.stp}中性格式文件中的主要内容如下。

\subsection{行内原样抄写并带有圆括号命令}
\label{ssc:pvp}

同理，如果不想两端不用引号（quotation marks），可以用圆括号（parentheses）的版本。
\verb|\pvp{}|
\footnote{已经有了 TvT 了，怎么能没有 PvP 呢？来自星际二的梗。}
。

名称属性 \pvp{N} 必须是文本格式、且不允许空格或特殊字符。
值属性 \pvp{V} 可以是常数、文本、函数表达式，或者引用其他的 对象元素。

\subsection{交叉引用}
\label{ssc:cross-ref-cmd}

先填充一些废话。\zhlipsum[10]

交叉引用命令 \textbackslash ref 是非常有用的，但是格式上有一个注意点：
最好在命令的前后用“不可分割空格”（即$\sim$）连接关键文字，以避免换行。
比如\tvt{图~\textbackslash 1.1 ~}

本次添加了关于“图”、“表”、“章节”等常用的交叉引用命令，方便调用。

然后测试一下新添加的交叉引用命令。
\begin{itemize}[\textbullet]
  \item \reftab{tab:tabularx}
  \item \reffig{fig:ken}
  \item \refalg{alg:test}
  \item \reflst{lst:outer}
  \item \refequ{eq:B}
  \item \refsec{ssc:cross-ref-cmd}
  \item \refcha{cha:intro}
\end{itemize}

好处是，VS Code 依然可以识别这些命令是交叉引用，所以括号内的自动补全是 label 没错。

但是，这种命令还不如直接用 snippet 完成呢，snippet 更具有灵活性。
所以，未来的版本可能会抛弃这个功能吧。

\subsection{圆圈序号}
这里是几个圆圈序号测试。

原生的命令特别丑陋。
圆圈序号1是这样的\textcircled{1}，圆圈序号2是这样的\textcircled{2}，圆圈序号3是这样的\textcircled{3}，圆圈序号4是这样的\textcircled{4}，可见并不美观\footnote{用 Tikz 绘制的}。

传统方法是利用 Pifont 宏包。
圆圈序号1是这样的\ding{172}，圆圈序号2是这样的\ding{173}，圆圈序号3是这样的\ding{174}，圆圈序号4是这样的\ding{175}，可见比较美观\footnote{pi font 的衬线命令}。

也可以用无衬线的数字。
圆圈序号1是这样的\ding{192}，圆圈序号2是这样的\ding{193}，圆圈序号3是这样的\ding{194}，圆圈序号4是这样的\ding{195}，可见也算美观\footnote{pi font 的非衬线衬线命令}。

投机的方法是用 Tikz 宏包。
圆圈序号1是这样的\tikzcircnum{1}，圆圈序号2是这样的\tikzcircnum{2}，圆圈序号3是这样的\tikzcircnum{3}，圆圈序号4是这样的\tikzcircnum{4}，可见也不错的\footnote{用 Tikz 绘制的}。

原生命令带星号则转化为 Tikz 方法。圆圈序号1是这样的\textcircled*{1}，圆圈序号2是这样的\textcircled*{2}，圆圈序号3是这样的\textcircled*{3}，圆圈序号4是这样的\textcircled*{4}，总之看得还行\footnote{原生命令重定义了，在本模板中调用的是 Tikz 方法，目的是兼容正文的字体样式}。

\subsection{特殊标记}
校友利用 Tikz 宏包绘制了同济的 logo。
在其基础上定义了几个 logo 命令没有用。
同济大学书写体校名 \tongjiname 测试。
同济大学英文小型大写字母文本 \tongjithesis 测试。

\end{document}
