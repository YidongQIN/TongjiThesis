% !TeX root = ../Main/thesis.tex
% !TEX program = xelatex
\documentclass[../Main/thesis]{subfiles}
\begin{document}
\chapter{新增内容测试}
\label{cha:new}

之前的两章都是原同济LaTeX模板中的内容。
这一章开始，就是修改、或新加内容的测试\cite{mohrssBIM}。

当然，不变的是满纸荒唐言，用于填充内容\cite{HowDigital}。

只不过偷了个懒：用 \verb|zhlipsum| 宏包填充废话充篇幅。

\section{多级标题} \label{sec:seclv}

先填充一些废话。\zhlipsum[4]

\subsection{多级标题样式修正}
\label{ssc:titles-style}

问题描述：原本的 \verb|romantitle| 命令没有用。

验证发现，是因为 \verb|CTeX| 宏包中的字体命令（\verb|\songti|、\verb|\heiti|、\verb|\fangsong|、\verb|\lishu|）等，只对汉字字体生效。
究其原因，因为是 \verb|xeCJK| 宏包的设计，使得CJK的字体可以独立于英语字体设置。

于是，重写了控制章节标题的数字编号的命令。
具体修改见 \tvt{README.md} 文件中的章节。
现在，可以在 \texttt{\textbackslash documentclass[titlenum=XXX]} 中启用不同的编号字体。
其中XXX可以选择如表~\ref{tab:title-number-format}所示。

\begin{table}[htbp]
\centering
\caption{\tongjithesis 章节编号样式选项}
\label{tab:title-number-format}
\begin{tabular}[c]{>{\ttfamily}lll}
  \toprule[1.5pt]
  选项 & 编号字体 & 备注 \\ % title row
  \midrule[1pt]
  rmtitlenum & 衬线（Times New Roman） & 本模板默认选项 \\
  sftitlenum & 无衬线（Arial） & 原模版默认选项 \\
  heititlenum & 黑体 & 严格按照校方模板 \\
  \bottomrule[1.5pt]
\end{tabular}
\end{table}

\subsection{二级节标题} \label{ssc:subsec2}

二级节标题形如\tvt{1.3.1 xxx}。

格式为：黑体，四号，顶左，单倍行距，段前 12 磅，段后 6 磅，序号与题名间空一个字符。

\subsubsection{三级节标题} \label{sss:subsub3}

三级节标题形如\tvt{1.3.1.1 xxx}。

格式为：黑体，小四，顶左，单倍行距，段前空 12 磅，段后空 6 磅，序号，且与题名间空一个字符。

\paragraph{四级标题即段落} \label{par:par4}

段落 paragraph 是本次新增的层次命令。

四级标题形如\tvt{（1）xxx}。

格式为：黑体，小四号，顶左，单倍行距，段前 6 磅，段后 0 磅，序号与题名间没有空。

格式是仿照正文的，区别就在黑体字体。

\paragraph{另一个四级标题} \label{spr:subpar}

其实，段落的样式已经与序号列表有一些相似了，相差可能也就是“黑体”以及“顶格书写”了吧。

至此，已经有了从0级chapter到4级paragraph共5个级别了，应该够了吧。

\subparagraph{如果必须要有更低的层次。\\}
如果必须要有最低等级的标题，就像必须要有巫妖王一样。

\sout{其实就是为了满足强迫症。}
故还是把最低层级的 subparagraph 样式给定义了。

\subparagraph{五级标题即子段落。}
五级标题形如 \tvt{\textcircled*{1}xxx}。

最初设定格式为：楷书，小四号，左侧空两格，单倍行距，段前 6 磅，段后 0 磅，序号与题名间没有空。
其中，用命令 \verb|\chinese{}| 产生汉字数字，并用命令 \verb|\setcounter{secnumdepth}{5}| 把目录编号深度更改为 subparagraph 对应的等级 5。

\subparagraph{但是样式过多也不好。}
应该不会用到这么多层级吧？
一个比较明显的问题就是 \verb|paragraph| 和 \verb|subparagraph| 的样式，难以与各类列表高效区分。
\footnote{所以如果内容不多，推荐采用列表，见第~\ref{sec:list}节的展示。}

所以选择了一个方案，其实就是避免与正文（列表）采用同样的字体。
四级标题的黑体是继承自校方模板的前几级标题设置，而五级标题的楷体参考了国家公文写作的有关规范\cite{GBT9704}。

\subparagraph{更新子段落样式。}
这是考虑到两方面原因：
\begin{inlinecn}
  \item 论文中完全没有说过“楷体”字体，擅自加入有些多余；
  \item 中文数字比如一、二、三等，并不适合作为低等级标题的数字编号，这不符合日常使用习惯。
\end{inlinecn}
所以，最终还是撤销了这些调整。

调整子段落的格式为这样：
\begin{inline}
  \item 子段落标题的字体格式与正文格式完全一样，只是会自动编号；
  \item 子段落标题与其他标题的差别在于，不会换行。
  \item 段落标题的字体与 section 相似，仍旧保持黑体、独立成段；
  \item 但是，段落标题的编号不像各级 section 那样包含上级编号。
\end{inline}

\subsubsection{段落编号}

需要更加完善地测试新命令。
现在测试用 subsubsection 分割后，能否正常编号。

\paragraph{一个新段落}

多补充几个段落测试。
经过 subsubsection 的分隔，现在应该是全新的段落了。

\paragraph{两个段落} \label{par:second}

正文格式是宋体，小四号（英文用 Times New Roman 体，小四号），两端对齐书写，段落首行左缩进 2 个汉字符。
行距 20 磅（段落中有数学表达式时，可根据表达需要设置该段的行距），段前段后 0 磅。

\subsection{最后的段落测试} \label{ssc:lastpar}

如果“跨级”中断呢？
比如这个，用section分隔之后，直接用paragraph会不会重新编号呢。

一下就用伟大的 Git 教程测试一下吧。

\paragraph{基本概念} \label{par:git-concept}

\paragraph{工作区}
working directory = workspace，就是电脑中的目录。

\paragraph{暂存区}
stage = staging area=index
而repository中最重要的就是称为stage（或者叫index）的暂存区
每次修改，如果不用git add到暂存区，那就不会加入到commit中

\paragraph{版本库}
repository = git directory =(local +remote)
可以简单理解成目录下隐藏的.git文件夹。

\paragraph{远程仓库}
remote = remote repository
一个主机，作为团队公用的仓库。一般就是GitHub、bitbucket、gitee 等git服务商。
本质上是一个git仓库的地址，形如 git@xxx.com:username/project。
在远程仓库管理中，会给它一个别名，通常是origin表示。

\paragraph{分支}
branch
一个仓库会有多个分支，对用不同的开发进度。
约定俗成的主分支叫master，也就是对外展示用的发布版本。

\subsection{总结章节样式}
\label{ssc:summary-title-formats}

实际上，章节样式划分为两类：
\begin{enumerate}[(1)]
  \item 章与各级节都是传统、常用的多层次数字编号，对应 \LaTeX 层次 0 $\sim$ 3。
  \begin{itemize}[\textbullet]
    \item 区别在于，本次新增了 subsubsetion 级别，即 “x.x.x.x” 的编号形式。
  \end{itemize}
  \item 段落是新增的，其编号由全角括号包围，对应 \LaTeX 层次 4 $\sim$ 5。
  \begin{itemize}[\textbullet]
    \item paragraph 的样式与章、节级相似，均为黑体、无缩进。
    \item subparagraph 的样式与正文相同，包括宋体、小四、缩进 2 字符。
  \end{itemize}
\end{enumerate}

\section{列表环境测试} \label{sec:list}

列表也是很常用的排版方式。
最方便的方法就是调用 enumerate 宏包定制标签，用 A a R r 1 分别代表大写字母、小写字母、大写罗马、小写罗马和阿拉伯数字编号。

为了偷懒和整齐，这次对一到三级列表的默认样式进行了设计。

\subsection{基本列表} \label{ssc:basiclist}

首先，先熟悉一下基本列表环境。
最常用的是有序列表。

\begin{enumerate}
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{enumerate}

也挺常用的无序列表。

\begin{itemize}
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{itemize}

本次修改的发起者，用description列表展示。
感觉这是一种不怎么常用的列表\footnote{大概是因为 word 中没有吧哈哈哈}。

\begin{description}
  \item[CNchence] 在github.com CNchence
  \item[marquistj13] 在github.com marquistj13
  \item[Wenda] 在github.com Williamwenda
  \item[CNchence] 在github.com CNchence
  \item[Wenda] 在github.com Williamwenda
\end{description}

更常见的是嵌套列表。

\subsection{嵌套}

先填充一些废话。\zhlipsum[6]

本小节的例子完全展示了 \emph{默认参数} 情况下的样式。

首先是有序列表。
\begin{enumerate}
  \item 介绍了时间序列分析的相关概念与理论。
  \item 重点对时间序列的平稳性特点
  \item 检验方法及平稳模型体系做了详细阐述。
  \begin{enumerate}
    \item 为充分反映出监测序列的季节周期性，建立了一套基于单测点监测序列的
    \item 对建模过程中的平稳性检验、模型建立步骤、定阶、参数估计以及检验进行了系统的阐述，
  \end{enumerate}
  \item 并对大桥某监测测点的实测数据进行了
  \item 结果表明
  \begin{enumerate}
    \item 用力地嵌套列表。
    \begin{enumerate}
      \item 针对监测序列中某些测点间具有较高的相似性，
      \item 探讨了滞后协整分析的参数估计
    \end{enumerate}
    \item 最后建立了支座位移与温度间的
    \item 结果表明该模型具有良好的拟合精度与预测效果。
  \end{enumerate}
\end{enumerate}

然后是无序列表的。
\begin{itemize}
  \item 介绍了时间序列分析的相关概念与理论。
  \item 重点对时间序列的平稳性特点
  \item 检验方法及平稳模型体系做了详细阐述。
  \begin{itemize}
    \item 为充分反映出监测序列的季节周期性，建立了一套基于单测点监测序列的
    \item 对建模过程中的平稳性检验、模型建立步骤、定阶、参数估计以及检验进行了系统的阐述，
  \end{itemize}
  \item 并对大桥某监测测点的实测数据进行了
  \item 结果表明
  \begin{itemize}
    \item 用力地嵌套列表。
    \begin{itemize}
      \item 针对监测序列中某些测点间具有较高的相似性，
      \item 探讨了滞后协整分析的参数估计
    \end{itemize}
    \item 最后建立了支座位移与温度间的
    \item 结果表明该模型具有良好的拟合精度与预测效果。
  \end{itemize}
\end{itemize}

下面是一个description列表，不知道中文叫什么。

\begin{description}
  \item [linxdcn] 在github.com linxdcn 同学汇总的、
  \item [svandex] 在 github.com svandex masthesis、
  \begin{description}
    \item [zhao-chen] 在 github.com zhao-chen TongjiThesis 的版本。
    \item [收藏有本硕博模板的zhouyuan版] 在 github.com zhouyuan tongjithesis。
  \end{description}
\end{description}

\zhlipsum[33]

顺便测试一下一个复杂的多级列表。
其实就是在嵌套的基础上， 手动定制多级列表的 label 形式。

\begin{enumerate}[1.]
  \item 调整本地工作目录
  \item 创建项目
  \begin{enumerate}[a.]
    \item 在git网站建立好新项目，把库克隆到本地 \\

    \verb| git clone http:// |

    \item 或者，直接在本地文件夹目录下初始化 \\

    \verb| git init |

    本地初始化后，如要连接网络远程仓库可以再用

    \verb| git remote add |
  \end{enumerate}

  \item 工作区 -> 暂存区：add添加（也叫stage）
    \begin{enumerate}[A.]
      \item 保存修改并添加文件到暂存区（index，或叫 staging area）

      \verb| git add <文件名> |

      常用简化命令如下：
        \begin{itemize}[\textbullet]
          \item \verb| git add -A | 所有更改
          \item \verb| git add .  | 新增、修改，不含删除
          \item \verb| git add -u | 修改、删除，不含新增
        \end{itemize}

      \item 或者查看区别

      \verb! git diff !
    \end{enumerate}

  \item 暂存区 -> 版本库：commit提交

  \verb| git commit -a -m "message" |

  其中，-a 表示全部 -m 添加一个留言。
  \begin{enumerate}[(a)]
    \item 如果弹出了vim截面，则用i命令进入编辑模式，
    \item 输入完成后，esc退回到命令模式，
    \item 然后：wq保存并退出vim，即可回到git命令窗口。
  \end{enumerate}

  \item * 确认提交状况  git status

  \item 推送到远程仓库

  \verb| git push -branch |

  之前步骤1-5都是在本地的版本管理，直到这一步才牵扯。
\end{enumerate}

下面是行内列表的展示。

\begin{inline}[1)]
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
  \item 中文 gb7714-2015.bbx
  \item gb7714-2015.bbx
  \item 中文 gb7714-2015ay.bbx
  \item gb7714-2015ay.bbx
\end{inline}

\section{表格测试} \label{sec:tabletest}

常用的表格是三线表。

\begin{table}[htb]
\centering
\caption{这不是个图}
\label{tab:fig}
\begin{tabular}[c]{lll}
  \toprule[1.5pt]
  0 & 1 & 2 \\ % title row
  \midrule[1pt]
  0 & 1 & 2 \\ % title row
  0 & 1 & 2 \\ % title row
  \bottomrule[1.5pt]
\end{tabular}
\end{table}

先填充一些废话。\zhlipsum[7]

在这里学习一下新定义的列形式。

\begin{table}[htb]
\centering
\caption{tabularx}
\label{tab:tabularx}
\begin{tabularx}{0.7\textwidth}{>{\raggedleft\arraybackslash}X>{\raggedleft\arraybackslash}X>{\centering\arraybackslash}X}
  \toprule[1.5pt]
  0 & 1 & 2 \\ % title row
  \midrule[1pt]
  0 & 1 & 2 \\ % title row
  0 & 1 & 2 \\ % title row
  \bottomrule[1.5pt]
\end{tabularx}
\end{table}

\section{代码环境}
\label{sec:code}

常用的代码展示，基于 Listings 宏包。

\subsection{Listings 环境展示}
\label{ssc:listings}

\begin{lstlisting}[style=monocolor,
  caption={first lst env},
  label={no label},
  name=测试第一个代码,
  language=PythonPlus]
  # import lxml
  import requests
  from bs4 import BeautifulSoup
  import re
\end{lstlisting}

先填充一些废话。\zhlipsum[8]

\begin{lstlisting}[language=ParamML,
  % caption=,
  % label=lst:,
  ]
<O  N="C4000Psi"  T="Material"  D="Concrete">
  <P N="d"  V="0.0000002248"  D="Density"/>
  <P N="E"  V="3604.9965"  D="Modulus of Elasticity"/>
  <P N="Fc28"  V="4"  D="Concrete Compressive Strength"/>
</O>
<!-- comment -->
\end{lstlisting}

不同于tabled 表~\ref{tab:fig}，源代码的展示用\ref{lst:inp}不会显示开头。
好吧，是我错了。都是需要手动指定其是“图”、“表”、“代码”或“章节”。\textbackslash ref 命令只显示编号。
仔细一想，这样也好，只做最小程度的工作，格式完全可以 \textbackslash newcommand 或者用 VSCode 脚本辅助。

\begin{lstlisting}[language=Python,
  caption=Second CODE Block,
  label=lst:2nd,
  style=colored]
  import numpy as np
  def incmatrix(genl1,genl2):
      m = len(genl1)
      #compute the bitwise xor matrix
      M1 = bitxormatrix(genl1)
      for i in range(m-1):
          for j in range(i+1, m):
              [r,c] = np.where(M2 == M1[i,j])
              for k in range(len(r)):
                  VT[(i)*n + r[k]] = 1;

                  if M is None:
                      M = np.copy(VT)
                  else:
                      M = np.concatenate((M, VT), 1)
      return M
\end{lstlisting}

为 宏包 Listings 定义了许多种语言和样式，比如XML，再基于XML定义了 ParamML。
语法比较简单，看看 \tvt{tongjithesis.sty} 文件 也就懂了。
故不赘述。

第~\ref{sec:code} 小节的内容也被引用了。

\begin{lstlisting}[language=Python,
  caption=中文标题没有括号,
  label=lst:outer,
  style=colorEX]
  import numpy as np
  def incmatrix(genl1,genl2):
      m = len(genl1)
      #compute the bitwise xor matrix
      M1 = bitxormatrix(genl1)
      for i in range(m-1):
          for j in range(i+1, m):
              [r,c] = np.where(M2 == M1[i,j])
              for k in range(len(r)):
                  VT[(i)*n + r[k]] = 1;
      return M
\end{lstlisting}

还可以直接导入一个外部文件，并摘选其中的部分行。

\lstinputlisting[language=Python,
  caption=inputted Python,
  label=lst:inp,
  style=monocolor,
  ]{../code/tmp.py}

先填充一些废话。\zhlipsum[12]

\subsubsection{代码片段 Listings 引用}

这里测试三个代码片段的引用。

代码片段，没有前缀，直接中括号，见 \ref{no label} 代码。

代码片段，是按照现有的snippet直接插入的样式 \ref{lst:2nd} 代码。

代码片段， \ref{lst:outer} 代码，手动在环境之后加了label，可以被 vscode 插件检测到。

代码片段， \ref{lst:parenthesis} 代码，仅供测试，caption 加了花括号。

貌似不能从ref命令中自动调用。难道需要手动加 label 更好吗？
\begin{lstlisting}[language=Python,
  caption={Must have Parenthesis},
  label=lst:parenthesis]
  import numpy as np
  def incmatrix(genl1,genl2):
      m = len(genl1)
      #compute the bitwise xor matrix
      M1 = bitxormatrix(genl1)
      for i in range(m-1):
          for j in range(i+1, m):
              [r,c] = np.where(M2 == M1[i,j])
              for k in range(len(r)):
                  VT[(i)*n + r[k]] = 1;
      return M
\end{lstlisting}
\subsection{算法}
\label{ssc:algo}

比代码更加抽象的方式就是算法展示了。

先填充一些废话。\zhlipsum[7]

\begin{minipage}{0.75\textwidth}

\begin{algorithm}[H]
  \caption{测试算法}
  \label{alg:test}
    \begin{algorithmic}[1]
      \REQUIRE PDf
      \ENSURE xelatex biber xelatex*2
      \IF{some condition is true}
      \STATE do some processing
      \ELSIF{some other condition is true}
      \STATE do some different processing
      \ELSIF{some even more bizarre condition is met}
      \STATE do something else
      \ELSE
      \STATE do the default actions
      \ENDIF
    \end{algorithmic}
  \end{algorithm}

\end{minipage}
\newline

但是好像用上的机会不多。

algorithm 是个 float 环境，相当于 table。
其宽度用 minipage 可以调整宽度，但是会取消 \textbackslash intextsep 导致上下间距过小。

\begin{enumerate}[(1)]
  \item 偷懒的方案是手动加竖向间距。
  \item 更好的方案是用另一个可以接受宽度的的浮动体包围、algorithm 以选项 H 放置其中。
  比如 tcolorbox、fullwidth 等。
\end{enumerate}

\section{特殊标记方式}
\label{sec:mark-methods}

先填充一些废话。\zhlipsum[9]

\subsection{下划线测试}
\label{ssc:underline}

这是默认的\underline{下划线功能}的效果。
可以看到，比 MS Word 的下划线好看多了，不会产生文字底线与下划线重合的问题。

\subsection{行内原样抄写并带有双引号命令}
\label{ssc:tvt}

考虑到会出现一些后缀名或者文件名之类的内容，所以新添了一个命令：
\verb|\tvt{}|，
其作用是在一个原样抄写的文字外围加上双引号。

CIS/2标准使用\tvt{*.stp}中性格式文件保存数据模型的数据。
对应上述梁的大纲，该梁在\texttt{*.stp}中性格式文件中的主要内容如下。

\subsection{行内原样抄写并带有圆括号命令}
\label{ssc:pvp}

同理，如果不想两端不用引号（quotation marks），可以用圆括号（parentheses）的版本。
\verb|\pvp{}|
\footnote{已经有了 TvT 了，怎么能没有 PvP 呢？来自星际二的梗。}
。

名称属性 \pvp{N} 必须是文本格式、且不允许空格或特殊字符。
值属性 \pvp{V} 可以是常数、文本、函数表达式，或者引用其他的 对象元素。

\subsection{交叉引用}
\label{ssc:cross-ref-cmd}

先填充一些废话。\zhlipsum[10]

交叉引用命令 \textbackslash ref 是非常有用的，但是格式上有一个注意点：
最好在命令的前后用“不可分割空格”（即$\sim$）连接关键文字，以避免换行。
比如\tvt{图 ~ \textbackslash 1.1 ~}

本次添加了关于“图”、“表”、“章节”等常用的交叉引用命令，方便调用。

然后测试一下新添加的交叉引用命令。
\begin{itemize}[\textbullet]
  \item \reftab{tab:tabularx}
  \item \reffig{fig:ken}
  \item \refalg{alg:test}
  \item \reflst{lst:outer}
  \item \refequ{eq:B}
  \item \refsec{ssc:cross-ref-cmd}
  \item \refcha{cha:intro}
\end{itemize}

好处是，VS Code 依然可以识别这些命令是交叉引用，所以括号内的自动补全是 label 没错。

但是，这种命令还不如直接用 snippet 完成呢，snippet 更具有灵活性。
所以，未来的版本可能会抛弃这个功能吧。

\subsection{圆圈序号}
这里是几个圆圈序号测试。

原生的命令特别丑陋。
圆圈序号1是这样的\textcircled{1}，圆圈序号2是这样的\textcircled{2}，圆圈序号3是这样的\textcircled{3}，圆圈序号4是这样的\textcircled{4}，可见并不美观\footnote{用 Tikz 绘制的}。

传统方法是利用 Pifont 宏包。
圆圈序号1是这样的\ding{172}，圆圈序号2是这样的\ding{173}，圆圈序号3是这样的\ding{174}，圆圈序号4是这样的\ding{175}，可见比较美观\footnote{pi font 的衬线命令}。

也可以用无衬线的数字。
圆圈序号1是这样的\ding{192}，圆圈序号2是这样的\ding{193}，圆圈序号3是这样的\ding{194}，圆圈序号4是这样的\ding{195}，可见也算美观\footnote{pi font 的非衬线衬线命令}。

投机的方法是用 Tikz 宏包。
圆圈序号1是这样的\tikzcircnum{1}，圆圈序号2是这样的\tikzcircnum{2}，圆圈序号3是这样的\tikzcircnum{3}，圆圈序号4是这样的\tikzcircnum{4}，可见也不错的\footnote{用 Tikz 绘制的}。

圆形命令带星号则转化为 Tikz 方法。圆圈序号1是这样的\textcircled*{1}，圆圈序号2是这样的\textcircled*{2}，圆圈序号3是这样的\textcircled*{3}，圆圈序号4是这样的\textcircled*{4}，总之看得还行\footnote{原生命令}。

\end{document}
